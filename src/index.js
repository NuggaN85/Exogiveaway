import { fileURLToPath } from 'url';
import path from 'path';
import dotenv from 'dotenv';
import { Client, Collection, GatewayIntentBits, Partials, EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle, PermissionsBitField, ChannelType, SlashCommandBuilder, ActivityType } from 'discord.js';
import { promises as fs } from 'fs';

// D√©finir __dirname pour les modules ES
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Configuration des variables d'environnement
dotenv.config();

// Cr√©er une nouvelle instance de client avec les intents n√©cessaires
const client = new Client({
  intents: [GatewayIntentBits.Guilds, GatewayIntentBits.GuildMessages],
  partials: [Partials.Channel, Partials.Message, Partials.User, Partials.GuildMember]
});

// Collection pour stocker les commandes
client.commands = new Collection();

// Rate limiter
const rateLimiter = new Map();
const limit = (userId, cooldown = 1000) => {
  const now = Date.now();
  if (rateLimiter.has(userId)) {
    const lastRequest = rateLimiter.get(userId);
    if (now - lastRequest < cooldown) return false;
  }
  rateLimiter.set(userId, now);
  return true;
};

// Gestion des giveaways
const storagePath = path.join(__dirname, 'giveaways.json');
const loadGiveaways = async () => {
  try {
    const data = await fs.readFile(storagePath, 'utf8');
    return JSON.parse(data);
  } catch (error) {
    return {};
  }
};
const saveGiveaways = async (giveaways) => {
  await fs.writeFile(storagePath, JSON.stringify(giveaways, null, 2));
};

// Cr√©ation d'embed
const createEmbed = (title, description, organizer, commentaire, color = 0x1F8B4C) => {
  const embed = new EmbedBuilder()
    .setTitle(title)
    .setDescription(description)
    .setColor(color);
  if (organizer) {
    embed.addFields({ name: 'Organisateur', value: `<@${organizer}>`, inline: true });
  }
  if (commentaire) {
    embed.addFields({ name: 'D√©tails', value: `\`${commentaire}\`` });
  }
  return embed;
};

// Formater le temps
function formatTime(ms) {
  if (ms < 60 * 1000) return `${Math.floor(ms / 1000)} secondes`;
  if (ms < 60 * 60 * 1000) return `${Math.floor(ms / (60 * 1000))} minutes`;
  if (ms < 24 * 60 * 60 * 1000) return `${Math.floor(ms / (60 * 60 * 1000))} heures`;
  return `${Math.floor(ms / (24 * 60 * 60 * 1000))} jours`;
}

function updateActivity() {
    client.user.setActivity(`Je suis sur ${client.guilds.cache.size} serveurs`, { type: ActivityType.Custom });
}

client.on("guildCreate", async guild => {
    updateActivity();
});

client.on("guildDelete", async guild => {
    updateActivity();
});

// √âv√©nement ready
client.once('ready', async () => {
  console.log(`‚úÖ Connect√© en tant que ${client.user.tag}!`);
  updateActivity();

  const giveaways = await loadGiveaways();
  for (const messageId in giveaways) {
    const giveaway = giveaways[messageId];
    const channel = await client.channels.fetch(giveaway.channelId).catch(() => null);
    if (!channel) continue;

    const message = await channel.messages.fetch(messageId).catch(() => null);
    if (!message) {
      delete giveaways[messageId];
      await saveGiveaways(giveaways);
      continue;
    }

    const participants = new Set(giveaway.participants);
    const remainingTime = giveaway.endTime - Date.now();
    if (remainingTime <= 0) {
      delete giveaways[messageId];
      await saveGiveaways(giveaways);
      continue;
    }

    const roleRequired = giveaway.r√¥leRequis ? channel.guild.roles.cache.get(giveaway.r√¥leRequis) : null;
    const embed = createEmbed(
      'üéâ Nouveau Giveaway en Cours üéâ',
      `
        **üéÅ Prix** : ${giveaway.prix}
        **üèÜ Gagnants** : ${giveaway.gagnants}
        **‚è≥ Temps restant** : ${formatTime(remainingTime)}
        **üë• Participants** : ${participants.size}
        ${roleRequired ? `**üîí R√¥le requis** : ${roleRequired}` : ''}
      `,
      giveaway.organizer,
      giveaway.commentaire
    )
      .setThumbnail(channel.guild.iconURL({ dynamic: true }))
      .setFooter({ text: 'Cliquez pour participer !', iconURL: channel.guild.iconURL() })
      .setTimestamp()
      .setImage('https://i.imgur.com/7ztYQMB.png');

    const row = new ActionRowBuilder()
      .addComponents(
        new ButtonBuilder().setCustomId('enter').setLabel('Participer').setStyle(ButtonStyle.Secondary).setEmoji('üéâ'),
        new ButtonBuilder().setCustomId('cancel').setLabel('Annuler').setStyle(ButtonStyle.Secondary).setEmoji('‚ùå'),
        new ButtonBuilder().setCustomId('show_participants').setLabel('Participants').setStyle(ButtonStyle.Secondary).setEmoji('üë•')
      );

    await message.edit({ embeds: [embed], components: [row] });

    const collector = message.createMessageComponentCollector({ time: remainingTime });

    collector.on('collect', async i => {
      if (i.customId === 'cancel') {
        if (!i.member.permissions.has(PermissionsBitField.Flags.ManageMessages)) {
          return i.reply({ content: '‚ùå Pas les permissions n√©cessaires.', ephemeral: true });
        }
        collector.stop('cancelled');
        delete giveaways[messageId];
        await saveGiveaways(giveaways);
        await i.reply({ content: '‚ö†Ô∏è Giveaway annul√©.', ephemeral: true });
        return;
      }

      if (i.customId === 'show_participants') {
        if (!i.member.permissions.has(PermissionsBitField.Flags.ManageMessages)) {
          return i.reply({ content: '‚ùå Pas les permissions n√©cessaires.', ephemeral: true });
        }
        const participantsList = Array.from(participants).map(id => `<@${id}>`).join(', ') || 'üë• Aucun participant.';
        const participantsEmbed = createEmbed('üìã Liste des Participants', participantsList, null, null)
          .setThumbnail(i.guild.iconURL())
          .setFooter({ text: 'Participants actuels', iconURL: i.guild.iconURL() })
          .setTimestamp();
        return i.reply({ embeds: [participantsEmbed], ephemeral: true });
      }

      if (giveaway.r√¥leRequis && !i.member.roles.cache.has(giveaway.r√¥leRequis)) {
        return i.reply({ content: `‚ùå Vous devez avoir le r√¥le ${roleRequired} pour participer.`, ephemeral: true });
      }

      if (participants.has(i.user.id)) {
        return i.reply({ content: '‚ùå Vous participez d√©j√†.', ephemeral: true });
      }

      participants.add(i.user.id);
      giveaways[messageId].participants = Array.from(participants);
      await saveGiveaways(giveaways);

      await i.reply({ content: 'üëç Vous participez ! Bonne chance !', ephemeral: true });

      const updatedEmbed = createEmbed(
        'üéâ Nouveau Giveaway en Cours üéâ',
        `
          **üéÅ Prix** : ${giveaway.prix}
          **üèÜ Gagnants** : ${giveaway.gagnants}
          **‚è≥ Temps restant** : ${formatTime(giveaway.endTime - Date.now())}
          **üë• Participants** : ${participants.size}
          ${roleRequired ? `**üîí R√¥le requis** : ${roleRequired}` : ''}
        `,
        giveaway.organizer,
        giveaway.commentaire
      )
        .setThumbnail(i.guild.iconURL({ dynamic: true }))
        .setFooter({ text: 'Cliquez pour participer !', iconURL: i.guild.iconURL() })
        .setTimestamp()
        .setImage('https://i.imgur.com/7ztYQMB.png');

      await message.edit({ embeds: [updatedEmbed] });
    });

    const interval = setInterval(async () => {
      const remainingTime = giveaways[messageId]?.endTime - Date.now();
      if (remainingTime <= 0) {
        clearInterval(interval);
        return;
      }

      const updatedEmbed = createEmbed(
        'üéâ Nouveau Giveaway en Cours üéâ',
        `
          **üéÅ Prix** : ${giveaway.prix}
          **üèÜ Gagnants** : ${giveaway.gagnants}
          **‚è≥ Temps restant** : ${formatTime(remainingTime)}
          **üë• Participants** : ${participants.size}
          ${roleRequired ? `**üîí R√¥le requis** : ${roleRequired}` : ''}
        `,
        giveaway.organizer,
        giveaway.commentaire
      )
        .setThumbnail(channel.guild.iconURL({ dynamic: true }))
        .setFooter({ text: 'Cliquez pour participer !', iconURL: channel.guild.iconURL() })
        .setTimestamp()
        .setImage('https://i.imgur.com/7ztYQMB.png');

      await message.edit({ embeds: [updatedEmbed] });
    }, 60000);

    collector.on('end', async (collected, reason) => {
      clearInterval(interval);

      if (reason === 'cancelled') {
        const cancelledEmbed = createEmbed('‚ùå Giveaway Annul√© ‚ùå', 'Le giveaway a √©t√© annul√©. Merci √† tous les participants !', giveaway.organizer, null, 0xE74C3C)
          .setThumbnail(channel.guild.iconURL({ dynamic: true }))
          .setFooter({ text: 'Merci √† tous !', iconURL: channel.guild.iconURL() })
          .setTimestamp();
        await message.edit({ embeds: [cancelledEmbed], components: [] });
        delete giveaways[messageId];
        await saveGiveaways(giveaways);
        return;
      }

      const winners = Array.from(participants).slice(0, giveaway.gagnants).map(id => channel.guild.members.cache.get(id)).filter(Boolean);
      const winnerEmbed = createEmbed(
        'üèÜ Giveaway Termin√© üèÜ',
        `
          **üéâ F√©licitations aux gagnants !**
          ${winners.length ? winners.map(w => `‚Ä¢ ${w.user.tag}`).join('\n') : 'Aucun participant.'}
          **üéÅ Prix** : ${giveaway.prix}
          **üèÜ Gagnants** : ${giveaway.gagnants}
        `,
        giveaway.organizer,
        giveaway.commentaire
      )
        .setThumbnail(channel.guild.iconURL({ dynamic: true }))
        .setFooter({ text: 'Merci √† tous les participants !', iconURL: channel.guild.iconURL() })
        .setTimestamp();

      await message.edit({ embeds: [winnerEmbed], components: [] });

      if (winners.length) {
        const thread = await message.startThread({
          name: `Gagnants - ${giveaway.prix}`,
          type: ChannelType.PrivateThread,
          autoArchiveDuration: 1440,
          reason: 'Thread priv√© pour les gagnants',
        });
        for (const winner of winners) {
          await thread.members.add(winner.id).catch(() => {});
        }

        const threadEmbed = createEmbed(
          'üéâ F√©licitations ! üéâ',
          `
            Vous avez gagn√© **${giveaway.prix}** !
            Contactez un mod√©rateur pour r√©clamer votre prix.
          `,
          giveaway.organizer,
          giveaway.commentaire
        )
          .setThumbnail(channel.guild.iconURL({ dynamic: true }))
          .setFooter({ text: 'F√©licitations !', iconURL: channel.guild.iconURL() })
          .setTimestamp();

        await thread.send({ content: winners.map(w => `<@${w.id}>`).join(', '), embeds: [threadEmbed] });
      }

      delete giveaways[messageId];
      await saveGiveaways(giveaways);
    });
  }
});

// √âv√©nement interactionCreate
client.on('interactionCreate', async (interaction) => {
  if (!interaction.isCommand()) return;

  const command = client.commands.get(interaction.commandName);
  if (!command) return;

  if (!limit(interaction.user.id)) {
    return interaction.reply({ content: '‚ùå Veuillez attendre avant de r√©essayer.', ephemeral: true });
  }

  try {
    await command.execute(interaction);
  } catch (error) {
    console.error('Erreur lors de l\'ex√©cution de la commande:', error);
    await interaction.reply({ content: '‚ö†Ô∏è Il y a eu une erreur lors de l\'ex√©cution de cette commande!', ephemeral: true });
  }
});

// Commande giveaway
client.commands.set('giveaway', {
  data: new SlashCommandBuilder()
    .setName('giveaway')
    .setDescription('Lancer un giveaway professionnel !')
    .addStringOption(option =>
      option.setName('prix')
        .setDescription('Le prix du giveaway')
        .setRequired(true)
    )
    .addIntegerOption(option =>
      option.setName('gagnants')
        .setDescription('Nombre de gagnants')
        .setRequired(true)
        .setMinValue(1)
    )
    .addStringOption(option =>
      option.setName('dur√©e')
        .setDescription('Dur√©e du giveaway')
        .setRequired(true)
        .addChoices(
          { name: '5 minutes', value: '5m' },
          { name: '10 minutes', value: '10m' },
          { name: '30 minutes', value: '30m' },
          { name: '1 heure', value: '1h' },
          { name: '3 heures', value: '3h' },
          { name: '5 heures', value: '5h' },
          { name: '1 jour', value: '1d' },
          { name: '3 jours', value: '3d' },
          { name: '5 jours', value: '5d' },
          { name: '1 semaine', value: '1w' }
        )
    )
    .addRoleOption(option =>
      option.setName('r√¥le_requis')
        .setDescription('R√¥le requis pour participer (optionnel)')
        .setRequired(false)
    )
    .addRoleOption(option =>
      option.setName('r√¥le_mention')
        .setDescription('R√¥le √† mentionner pour annoncer le giveaway (optionnel)')
        .setRequired(false)
    )
    .addStringOption(option =>
      option.setName('commentaire')
        .setDescription('Commentaire ou informations suppl√©mentaires (optionnel)')
        .setRequired(false)
    ),
  async execute(interaction) {
    if (!interaction.member.permissions.has(PermissionsBitField.Flags.ManageMessages)) {
      return interaction.reply({ content: '‚ùå Permissions insuffisantes pour lancer un giveaway.', ephemeral: true });
    }

    const prix = interaction.options.getString('prix');
    const gagnants = interaction.options.getInteger('gagnants');
    const dur√©eInput = interaction.options.getString('dur√©e');
    const r√¥leRequis = interaction.options.getRole('r√¥le_requis');
    const r√¥leMention = interaction.options.getRole('r√¥le_mention');
    const commentaire = interaction.options.getString('commentaire');
    const organizer = interaction.user.id;

    const dur√©eMap = {
      '5m': 5 * 60 * 1000,
      '10m': 10 * 60 * 1000,
      '30m': 30 * 60 * 1000,
      '1h': 60 * 60 * 1000,
      '3h': 3 * 60 * 60 * 1000,
      '5h': 5 * 60 * 60 * 1000,
      '1d': 24 * 60 * 60 * 1000,
      '3d': 3 * 24 * 60 * 60 * 1000,
      '5d': 5 * 24 * 60 * 60 * 1000,
      '1w': 7 * 24 * 60 * 60 * 1000,
    };
    const dur√©eMs = dur√©eMap[dur√©eInput];
    const dur√©eText = {
      '5m': '5 minutes', '10m': '10 minutes', '30m': '30 minutes',
      '1h': '1 heure', '3h': '3 heures', '5h': '5 heures',
      '1d': '1 jour', '3d': '3 jours', '5d': '5 jours', '1w': '1 semaine'
    }[dur√©eInput];

    const embed = createEmbed(
      'üéâ Nouveau Giveaway üéâ',
      `
        **üéÅ Prix** : ${prix}
        **üèÜ Gagnants** : ${gagnants}
        **‚è≥ Dur√©e** : ${dur√©eText}
        ${r√¥leRequis ? `**üîí R√¥le requis** : ${r√¥leRequis}` : ''}
      `,
      organizer,
      commentaire
    )
      .setThumbnail(interaction.guild.iconURL({ dynamic: true }))
      .setFooter({ text: 'Cliquez pour participer !', iconURL: interaction.guild.iconURL() })
      .setTimestamp()
      .setImage('https://i.imgur.com/7ztYQMB.png');

    const row = new ActionRowBuilder()
      .addComponents(
        new ButtonBuilder().setCustomId('enter').setLabel('Participer').setStyle(ButtonStyle.Secondary).setEmoji('üéâ'),
        new ButtonBuilder().setCustomId('cancel').setLabel('Annuler').setStyle(ButtonStyle.Secondary).setEmoji('‚ùå'),
        new ButtonBuilder().setCustomId('show_participants').setLabel('Participants').setStyle(ButtonStyle.Secondary).setEmoji('üë•')
      );

    const content = r√¥leMention ? `<@&${r√¥leMention.id}> Nouveau giveaway a √©t√© lanc√©` : null;

    const message = await interaction.reply({
      content,
      embeds: [embed],
      components: [row],
      fetchReply: true
    });

    const giveaways = await loadGiveaways();
    const participants = new Set();
    giveaways[message.id] = {
      channelId: interaction.channelId,
      guildId: interaction.guildId,
      prix,
      gagnants,
      endTime: Date.now() + dur√©eMs,
      participants: Array.from(participants),
      r√¥leRequis: r√¥leRequis ? r√¥leRequis.id : null,
      commentaire: commentaire || null,
      organizer
    };
    await saveGiveaways(giveaways);

    const collector = message.createMessageComponentCollector({ time: dur√©eMs });

    collector.on('collect', async i => {
      if (r√¥leRequis && !i.member.roles.cache.has(r√¥leRequis.id)) {
        return i.reply({ content: `‚ùå Vous devez avoir le r√¥le ${r√¥leRequis} pour participer.`, ephemeral: true });
      }

      if (i.customId === 'cancel') {
        if (!i.member.permissions.has(PermissionsBitField.Flags.ManageMessages)) {
          return i.reply({ content: '‚ùå Permissions insuffisantes pour annuler.', ephemeral: true });
        }
        collector.stop('cancelled');
        delete giveaways[message.id];
        await saveGiveaways(giveaways);
        await i.reply({ content: '‚ö†Ô∏è Giveaway annul√©.', ephemeral: true });
        return;
      }

      if (i.customId === 'show_participants') {
        if (!i.member.permissions.has(PermissionsBitField.Flags.ManageMessages)) {
          return i.reply({ content: '‚ùå Permissions insuffisantes pour voir les participants.', ephemeral: true });
        }
        const participantsList = Array.from(participants).map(id => `<@${id}>`).join(', ') || 'Aucun participant.';
        const participantsEmbed = createEmbed('üìã Liste des Participants', participantsList, null, null)
          .setThumbnail(i.guild.iconURL({ dynamic: true }))
          .setFooter({ text: 'Participants actuels', iconURL: i.guild.iconURL() })
          .setTimestamp();
        return i.reply({ embeds: [participantsEmbed], ephemeral: true });
      }

      if (participants.has(i.user.id)) {
        return i.reply({ content: '‚ùå Vous participez d√©j√†.', ephemeral: true });
      }

      participants.add(i.user.id);
      giveaways[message.id].participants = Array.from(participants);
      await saveGiveaways(giveaways);

      await i.reply({ content: '‚úÖ Vous avez rejoint le giveaway ! Bonne chance !', ephemeral: true });

      const updatedEmbed = createEmbed(
        'üéâ Nouveau Giveaway en Cours üéâ',
        `
          **üéÅ Prix** : ${prix}
          **üèÜ Gagnants** : ${gagnants}
          **‚è≥ Temps restant** : ${formatTime(giveaways[message.id].endTime - Date.now())}
          **üë• Participants** : ${participants.size}
          ${r√¥leRequis ? `**üîí R√¥le requis** : ${r√¥leRequis}` : ''}
        `,
        organizer,
        commentaire
      )
        .setThumbnail(interaction.guild.iconURL({ dynamic: true }))
        .setFooter({ text: 'Cliquez pour participer !', iconURL: interaction.guild.iconURL() })
        .setTimestamp()
        .setImage('https://i.imgur.com/7ztYQMB.png');

      await message.edit({ embeds: [updatedEmbed] });
    });

    const interval = setInterval(async () => {
      const remainingTime = giveaways[message.id]?.endTime - Date.now();
      if (remainingTime <= 0) {
        clearInterval(interval);
        return;
      }

      const updatedEmbed = createEmbed(
        'üéâ Nouveau Giveaway en Cours üéâ',
        `
          **üéÅ Prix** : ${prix}
          **üèÜ Gagnants** : ${gagnants}
          **‚è≥ Temps restant** : ${formatTime(remainingTime)}
          **üë• Participants** : ${participants.size}
          ${r√¥leRequis ? `**üîí R√¥le requis** : ${r√¥leRequis}` : ''}
        `,
        organizer,
        commentaire
      )
        .setThumbnail(interaction.guild.iconURL({ dynamic: true }))
        .setFooter({ text: 'Cliquez pour participer !', iconURL: interaction.guild.iconURL() })
        .setTimestamp()
        .setImage('https://i.imgur.com/7ztYQMB.png');

      await message.edit({ embeds: [updatedEmbed] });
    }, 60000);

    collector.on('end', async (collected, reason) => {
      clearInterval(interval);
      if (!giveaways[message.id]) return;

      if (reason === 'cancelled') {
        const cancelledEmbed = createEmbed('‚ùå Giveaway Annul√© ‚ùå', 'Le giveaway a √©t√© annul√©. Merci √† tous les participants !', organizer, null, 0xE74C3C)
          .setThumbnail(interaction.guild.iconURL({ dynamic: true }))
          .setFooter({ text: 'Merci √† tous !', iconURL: interaction.guild.iconURL() })
          .setTimestamp();
        await message.edit({ embeds: [cancelledEmbed], components: [] });
        delete giveaways[message.id];
        await saveGiveaways(giveaways);
        return;
      }

      const winners = Array.from(participants).slice(0, gagnants).map(id => interaction.guild.members.cache.get(id)).filter(Boolean);
      const winnerEmbed = createEmbed(
        'üèÜ Giveaway Termin√© üèÜ',
        `
          **üéâ F√©licitations aux gagnants !**
          ${winners.length ? winners.map(w => `‚Ä¢ ${w.user.tag}`).join('\n') : 'Aucun participant.'}
          **üéÅ Prix** : ${prix}
          **üèÜ Gagnants** : ${gagnants}
        `,
        organizer,
        commentaire
      )
        .setThumbnail(interaction.guild.iconURL({ dynamic: true }))
        .setFooter({ text: 'Merci √† tous les participants !', iconURL: interaction.guild.iconURL() })
        .setTimestamp();

      await message.edit({ embeds: [winnerEmbed], components: [] });

      if (winners.length) {
        const thread = await message.startThread({
          name: `Gagnants - ${prix}`,
          type: ChannelType.PrivateThread,
          autoArchiveDuration: 1440,
          reason: 'Thread priv√© pour les gagnants',
        });
        for (const winner of winners) {
          await thread.members.add(winner.id).catch(() => {});
        }

        const threadEmbed = createEmbed(
          'üéâ F√©licitations ! üéâ',
          `
            Vous avez gagn√© **${prix}** !
            Contactez un mod√©rateur pour r√©clamer votre prix.
          `,
          organizer,
          commentaire
        )
          .setThumbnail(interaction.guild.iconURL({ dynamic: true }))
          .setFooter({ text: 'F√©licitations !', iconURL: interaction.guild.iconURL() })
          .setTimestamp();

        await thread.send({ content: winners.map(w => `<@${w.id}>`).join(', '), embeds: [threadEmbed] });
      }

      delete giveaways[message.id];
      await saveGiveaways(giveaways);
    });
  }
});

// Connecter le bot √† Discord
client.login(process.env.DISCORD_TOKEN)
  .then(() => console.log('‚úÖ Connect√© √† Discord avec succ√®s.'))
  .catch(error => console.error('‚ö†Ô∏è Erreur lors de la connexion √† Discord:', error));
